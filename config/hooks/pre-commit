#!/bin/bash +x

modified_files="git diff --cached --name-only --diff-filter=ACMRTUXB"

patron="^D[D|M]L_[0-9]{3,5}_(ENTITY0[0-9]|BANK01|HAYA0[0-9]|REM01|CM01|HAYAMASTER|REMMASTER|MASTER|BANKMASTER|CMMASTER|MINIREC|HAYA0[0-9]D15|HAYAMASTERD15|DWH|DS)_.*\.sql"

function mostrar_error() {
	echo -e "\n$1\n"
	exit 1
}

function paint_error() {
	declare -n error_data=$1
	echo ""
	echo "**********************************************************"
	echo "Control código PFS: ${error_data[name]}"
	echo "Commit no permitido!!!"
	echo "Fichero afectado: ${error_data[file]}"
	echo ""
	echo "Problema: ${error_data[problem]}"
	echo "Solución: ${error_data[solution]}"
	echo "**********************************************************"
	echo ""
}


function check_RIA_RULE_R1() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R1"
						[file]=$f 
						[problem]="Estás intentando incorporar un debugger en la interface, es muy peligroso."
						[solution]="Elimina la instrucción 'debugger'" )

	r=$(echo $file_content | grep "debugger")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R2() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R2"
						[file]=$f 
						[problem]="Estás intentando poner comentarios HTML en una JSP."
						[solution]="Convierte tus comentarios <!-- --> en comentarios JSP <%-- --%> o preferiblemente elimina las líneas comentadas." )

	r=$(echo $file_content | grep "<\!--.*-->")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R3() {
	file_content=$1
	regexp=",\s*(,|\]|\}|\)|(\<sec)(.*?)(\>),|(\<\/sec)(.*?)(\>)\s*(.*?)\s*(\<sec)(.*?)(\>),)"

	declare -A rule=(	[name]="RIA_RULE_R3"
						[file]=$f 
						[problem]="Estás intentando poner COMAS FURTIVAS en una JSP."
						[solution]="Revisa el siguiente enlace: https://link-doc.pfsgroup.es/confluence/x/CQDU.
Expresion regular para detectar comas furtivas: $regexp" )

	r=$(echo $file_content | sed 's/'"'"'.*'"'"'/_string_/g' \
                  | sed 's/".*"/_string_/g' \
                  | sed 's/replace(.*\,.*)/_regexp_/g' \
                  | grep -Pzo "$regexp")

	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R4() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R4"
						[file]=$f 
						[problem]="Esta expresión es problemática para IExplorer 'border:false'."
						[solution]="Reemplaza esta expresión por 'border:0px'." )

	r=$(echo $file_content | grep -E "border(\s*):(\s*)false")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R5() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R5"
						[file]=$f 
						[problem]="Esta expresión es problemática para IExplorer 'renderer:app.format.dateRenderer,'."
						[solution]="Reemplaza esta expresión por su equivalente en el JSON o Dto original." )

	r=$(echo $file_content | grep -E "renderer(\s*):(\s*)app.format.dateRenderer,")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_UTF8() {
	file=$1
	declare -A rule=(	[name]="Encodig (UTF-8/ASCII)"
						[file]=$file 
						[problem]="El fichero no está en formato correcto UTF-8 o ASCII."
						[solution]="Convierte el encoding del fichero a u UTF8." )

	encoding=`file -i $file | cut -f 2 -d";" | cut -f 2 -d=`
	if [ $encoding != "utf-8" ] &&  [ $encoding != "us-ascii" ]; then
		paint_error rule
	    exit 1
	fi

}

function check_pitertul_format() {
	f=$1
	expregular=$2
	declare -A rule=(	[name]="Pitertul format"
						[file]=$f
						[problem]="El fichero no está en formato correcto para PITERTUL."
						[solution]="$3"
					)
	r=$(cat $f | tr '\n' ' ' | tr '\t' ' ' | tr -s [:space:] | tr -cd "[:print:]" | 
		grep -a -E -i "$expregular")
	if [[ "x" == "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_pitertul_name() {
	file=$1
	declare -A rule=(	[name]="Pitertul nombre"
						[file]=$file
						[problem]="El fichero no tiene un nombre correcto para PITERTUL."
						[solution]="Patrón válido: $patron"
					)
	fsinpath=${file##*/}
	if [[ ! $fsinpath =~ $patron ]] ; then 
		paint_error rule
		exit 1
	fi
}

# ***************************
# Control en RIA
# ***************************
function JSP_rules() {
	for f in `eval $modified_files | grep .jsp$`; do
		
		file_content=$(cat $f);

		# R1-RIA. Control de debugger en JSPs
		check_RIA_RULE_R1 "$file_content"
		# R2-RIA.  Control de comentarios en JSPs
		check_RIA_RULE_R2 "$file_content"
		# R3-RIA.  Control de comas furtivas
		check_RIA_RULE_R3 "$file_content"
		# R4-RIA.  Control de reglas border:false (desactivada)
		#check_RIA_RULE_R4 "$file_content"
		# R5-RIA.  Control de reglas dateRenderer()
		check_RIA_RULE_R5 "$file_content"
	done
}

# ***************************
# Control en JS y SQL
# ***************************
function JS_rules() {
	for f in `eval $modified_files | grep .js$`; do
		
		file_content=$(cat $f);

		# R1-RIA. Control de debugger en JSPs
		check_RIA_RULE_R1 "$file_content"
		# R3-RIA.  Control de comas furtivas
		check_RIA_RULE_R3 "$file_content"
	done
}

function SQL_rules() {
	for f in `eval $modified_files | grep  -E \/D.*\.sql$ | grep -v ^reports/ | grep -v migracion | grep -v scripts | grep -v templates | grep -v rutinas`; do
		check_pitertul_name $f
		
		check_UTF8 $f

		exp="\s*WHENEVER\s*SQLERROR\s*EXIT\s*SQL\.SQLCODE(;|)\s*"
		check_pitertul_format $f $exp "Debe incluir 'WHENEVER SQLERROR EXIT SQL.SQLCODE;'"
		exp="SET\s*SERVEROUTPUT\s*ON(;|)"
		check_pitertul_format $f $exp "Debe incluir 'SET SERVEROUTPUT ON;'"
		exp="(DECLARE|CREATE)"
		check_pitertul_format $f $exp "Debe incluir un bloque DECLARE o CREATE"
		exp="BEGIN"
		check_pitertul_format $f $exp "Debe incluir un bloque BEGIN"
		exp="EXCEPTION"
		check_pitertul_format $f $exp "Debe incluir un bloque EXCEPTION"
		exp="ROLLBACK;"
		check_pitertul_format $f $exp "Debe incluir una línea ROLLBACK; dentro del bloque EXCEPTION"
		exp="RAISE;"
		check_pitertul_format $f $exp "Debe incluir  una línea RAISE; dentro del bloque EXCEPTION"
		exp="END(.*);\s*/"
		check_pitertul_format $f $exp "Debe incluir un bloque finalizado con END; o END <nombre_sp>;"
		exp="/\s*EXIT(;|)\s*$"
		check_pitertul_format $f $exp "Debe finalizar con '/ y EXIT'"
	done
}

function PROPERTIES_rules() {
	for f in `eval $modified_files | grep  -E '.properties$'`; do
		check_UTF8 $f
	done
}

function check_conflictos() {
	file=$1
	declare -A rule=(	[name]="Conflictos git no resueltos"
						[file]=$file 
						[problem]="El fichero contiene trazas de conflictos git no resueltos."
						[solution]="Revise que no contenga cadenas '>>>>>>', '<<<<<<<' o '======='." )

	hay_conflictos=`cat $file | grep -E '^[+]?(>>>>>>|<<<<<<<|=======)' | wc -l`
	if [ $hay_conflictos -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function ficheros_rules() {
	for f in `eval $modified_files`; do
		check_conflictos $f
	done
}

function check_esquema_hardcodeado() {
	file=$1
	declare -A rule=(	[name]="Esquema hardcodeado en fichero sql"
						[file]=$file 
						[problem]="Se ha detectado un nombre de esquema hardcodeado en un fichero sql."
						[solution]="Revise que no (contenga BANK01|HAYA0[0-9]|REM01|CM01|ALI01|HAYAMASTER|REMMASTER|ALIMASTER|BANKMASTER|CMMASTER)" )

	existe=`sed "s/--.*$//" $f | grep -iE '(BANK01|HAYA0[0-9]|REM01|CM01|ALI01|ESCO01|SAR01|HAYAMASTER|REMMASTER|ALIMASTER|BANKMASTER|CMMASTER|ESCOMASTER|SARMASTER)' | grep -v WHEN | grep -v THEN | grep -v '=' | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_hardcode_rules() {
	for f in `eval $modified_files | grep -E \/D.*\.sql$ | grep 'producto/' `; do
		check_esquema_hardcodeado $f
	done
}

function check_ddl() {
	file=$1
	declare -A rule=(	[name]="Fichero DDL en una ubicación incorrecta"
						[file]=$file 
						[problem]="Se ha detectado un fichero DDL.sql fuera de la carpeta producto."
						[solution]="Mueva este fichero a la carpeta producto. Sólo se permiten scripts de creación de tablas TMP o AUX fuera de la carpeta de producto" )
	creates_totales=`cat $file | grep -iE "create table " | wc -l`
	creates_ok=`cat $file | grep -iE "create table .*(aux|tmp)" | wc -l`
	echo $creates_totales $creates_ok
	if [ $creates_totales -gt $creates_ok ]; then
		paint_error rule
	    exit 1
	fi
}

function check_ddl_content() {
	file=$1
	declare -A rule=(	[name]="Fichero DDL con contenido incorrecto"
						[file]=$file 
						[problem]="Se han detectado campos o tablas del DDL demasiado largas."
						[solution]="Modifique la longitud menor o igual a 30." )

	IN1=$(cat $file | awk -F- 'NF<=2' $file | tr ',' ' ' | tr '(' ' ' | tr ')' ' '| tr -s ' ' | tr '\n' ' ' | sed 's/a/aA/g; s/__/aB/g; s/#/aC/g' | gcc -P -E $file -  | sed 's/aC/#/g; s/aB/__/g; s/aA/a/g')
	IFS=' ' read -ra ADDR1 <<< "$IN1"
	cons=`echo "${ADDR1[0]}"`
	
	for i in "${ADDR1[@]}"; do
		
		cons=`echo "$i" | sed 's/[!@#\$%^&*()/;=,:|]//g' | grep -vwE '\w{1,30}' | wc -c`
		concomillas=`echo "$i" | sed 's/[!@#\$%^&*()/;=,:|]//g' | grep -vwE '\w{1,30}'`
		findcomillas=`echo "$i" | grep -o "'.*'"`
		
		if [[ "${concomillas}" == "${findcomillas}" ]] && [[ "${concomillas}" != "" ]] && [[ "${findcomillas}" != "" ]]; then
			x=1
		else
			if [[ ${cons} -gt 28 ]]; then
				paint_error rule
			    exit 1
			fi
		fi
	done
}

function check_withGrantOptions() {
	file=$1
	declare -A rule=(	[name]="Fichero DDL con contenido incorrecto"
						[file]=$file 
						[problem]="Se han detectado la sentencia WITH GRANT OPTION en el DDL."
						[solution]="Revise si es necesario incluir WITH GRANT OPTION" )

	existe=`cat $file | grep -iE "with grant option" | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_ddl_rules() {
	for f in `eval $modified_files | grep -E \/DD.*\.sql$ | grep -v producto | grep -v ^procs_y_vistas/ | grep -v ^reports/ | grep -v migracion | grep -v scripts | grep -v templates | grep -v rutinas | grep -v produccion | grep -v incidencias | grep -v rem_fase1 | grep -v informacional | grep -v convivencia | grep -v tmp | grep -v 9\.2 | grep -v 9\.3 | grep -v 9\.4 |  grep -v no_protocolo | grep -v sincro_f2 `; do
		check_ddl $f
		check_ddl_content $f
		check_withGrantOptions $f
	done
}

function check_dml() {
	file=$1
	declare -A rule=(	[name]="Fichero DML con contenido incorrecto"
						[file]=$file 
						[problem]="Se han detectado sentencias DDL dentro de un fichero DML."
						[solution]="Revise que no contenga sentencias (CREATE TABLE|ALTER TABLE|DROP TABLE)" )

	existe=`cat $file | grep -iE "(create table|alter table|drop table)" | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_dml_rules() {
	for f in `eval $modified_files | grep -E \/DM.*\.sql$ | grep -v ^reports/ | grep -v migracion | grep -v scripts | grep -v templates | grep -v rutinas | grep -v produccion | grep -v incidencias | grep -v rem_fase1 | grep -v informacional | grep -v convivencia | grep -v tmp | grep -v 9\.2 | grep -v 9\.3 | grep -v 9\.4 |  grep -v no_protocolo | grep -v sincro_f2 `; do
		check_dml $f
	done
}

function check_select() {
	file=$1
	declare -A rule=(	[name]="Script con contenido incorrecto (SELECT *)"
						[file]=$file 
						[problem]="Se han detectado sentencias SELECT * dentro de un script"
						[solution]="Revise que no contenga sentencias (SELECT *). Sustitúyalas por SELECT <lista_de_campos>" )

	existe=`cat $file | grep -Eia 'SELECT \*' | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_rules2() {
	for f in `eval $modified_files | grep -Ei '*\.sql$'`; do
		check_select $f
	done
}

function Script_schema() {
	file=$1
	
	patron2="^D[D|M]L_[0-9]{3,5}_(DWH|DS)_.*\.sql"

	declare -A rule=(	[name]="Nombre Script/Localización incorrecto dentro de informacional"
						[file]=$file
						[problem]="El fichero se encuentra en una localización incorrecta"
						[solution]="Patrón válido: $patron2"
					)
	fsinpath=${file##*/}
	
	if [[ ! $fsinpath =~ $patron2 ]] ; then 
		paint_error rule
		exit 1
	fi
}

function Script_schema_bi() {
	file=$1
	
	patron2="^D[D|M]L_[0-9]{3,5}_(DWH|DS)_.*\.sql"
	patronNoBi="^D[D|M]L_[0-9]{3,5}_(ENTITY0[0-9]|BANK01|HAYA0[0-9]|REM01|CM01|HAYAMASTER|REMMASTER|MASTER|BANKMASTER|CMMASTER|MINIREC)_.*\.sql"
	declare -A rule=(	[name]="Nombre Script/Localización incorrecto fuera de informacional"
						[file]=$file
						[problem]="El fichero se encuentra en una localización incorrecta"
						[solution]="Patrón válido: $patronNoBi"
					)
	fsinpath=${file##*/}
	
	if [[  $fsinpath =~ $patron2 ]] ; then 
		paint_error rule
		exit 1
	fi
}



function Schema_rules() {
	for f in `eval $modified_files | grep informacional | grep sql`; 
	do 
		Script_schema $f
	done

	for f in `eval $modified_files | grep -v informacional | grep sql`; 
	do 
		Script_schema_bi $f
	done
}


function Commit_rules () {

	rama_actual=`git branch | grep '*' | cut -d' ' -f2`
	echo "Rama actual: $rama_actual" 
	dir_txt=$(dirname "$0")
	ficheroramasbloqueadas=${dir_txt}/tool/ramas-subidas-pro.txt

	for ruta in `cat $ficheroramasbloqueadas` ; do  
		rama=`echo "$ruta"`
		merge_bloqueadas $rama_actual $rama
	done

}

merge_bloqueadas() {

	rama_actual=`echo $1 | sed 's/@/.+/'`
	ruta_origen=`echo $2 | sed 's/@/.+/'`

	if [[ $ruta_origen =~ $rama_actual ]] ; then
		mostrar_error "No se puede comitear en la rama $rama_actual ,se encuentra bloqueada porque ya está en PRODUCCIÓN"
		exit 1
	fi

}

function vproperties_rules () {
	result=0
	ficheros=$(git diff --cached --name-only --diff-filter=ACM | grep versiones.properties)
	ruta_ini=$(pwd)
	ruta_fin=$(echo $(git rev-parse --show-toplevel))

	cd $ruta_fin

	for fichero in $ficheros
	do
		num_total=$(cat $fichero | cut -d ":" -f-2 | sort | wc -l)
		num_fin=$(cat $fichero | cut -d ":" -f-2 | sort | uniq | wc -l)

		if [ "$num_total" -ne "$num_fin" ]; then
			repetidos=$(cat $fichero | cut -d ":" -f-2 | sort | uniq -d)
			etls=$(cat $fichero | sort | grep "$repetidos")
			echo -e "\nEn el fichero $fichero tiene las siguientes repeticiones."
			echo -e "Por favor, modificalos antes de subir los cambios:\n"
			echo -e "$etls\n"
			result=1
		fi
	done

	cd $ruta_ini

	if [ "$result" -eq 1 ]; then
		exit 1;
	fi
}

########################################################
##### MAIN
########################################################

check_ddl_content
SQL_ddl_rules
SQL_dml_rules
SQL_hardcode_rules
ficheros_rules
JSP_rules
JS_rules
SQL_rules
SQL_rules2
Schema_rules
Commit_rules
vproperties_rules

exit 0
