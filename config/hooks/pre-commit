#!/bin/bash +x

modified_files="git diff --cached --name-only --diff-filter=ACMRTUXB"
patron="^D[D|M]L_[0-9]{3,5}_(ENTITY0[0-9]|BANK01|HAYA0[0-9]|REM01|CM01|HAYAMASTER|REMMASTER|MASTER|BANKMASTER|CMMASTER|MINIREC|HAYA0[0-9]D15|HAYAMASTERD15|DWH|DS)_.*\.sql"

function paint_error() {
	declare -n error_data=$1
	echo ""
	echo "**********************************************************"
	echo "Control código PFS: ${error_data[name]}"
	echo "Commit no permitido!!!"
	echo "Fichero afectado: ${error_data[file]}"
	echo ""
	echo "Problema: ${error_data[problem]}"
	echo "Solución: ${error_data[solution]}"
	echo "**********************************************************"
	echo ""
}


function check_RIA_RULE_R1() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R1"
						[file]=$f 
						[problem]="Estás intentando incorporar un debugger en la interface, es muy peligroso."
						[solution]="Elimina la instrucción 'debugger'" )

	r=$(echo $file_content | grep "debugger")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R2() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R2"
						[file]=$f 
						[problem]="Estás intentando poner comentarios HTML en una JSP."
						[solution]="Convierte tus comentarios <!-- --> en comentarios JSP <%-- --%> o preferiblemente elimina las líneas comentadas." )

	r=$(echo $file_content | grep "<\!--.*-->")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R3() {
	file_content=$1
	regexp=",\s*(,|\]|\}|\)|(\<sec)(.*?)(\>),|(\<\/sec)(.*?)(\>)\s*(.*?)\s*(\<sec)(.*?)(\>),)"

	declare -A rule=(	[name]="RIA_RULE_R3"
						[file]=$f 
						[problem]="Estás intentando poner COMAS FURTIVAS en una JSP."
						[solution]="Revisa el siguiente enlace: https://link-doc.pfsgroup.es/confluence/x/CQDU.
Expresion regular para detectar comas furtivas: $regexp" )

	r=$(echo $file_content | sed 's/'"'"'.*'"'"'/_string_/g' \
                  | sed 's/".*"/_string_/g' \
                  | sed 's/replace(.*\,.*)/_regexp_/g' \
                  | grep -Pzo "$regexp")

	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R4() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R4"
						[file]=$f 
						[problem]="Esta expresión es problemática para IExplorer 'border:false'."
						[solution]="Reemplaza esta expresión por 'border:0px'." )

	r=$(echo $file_content | grep -E "border(\s*):(\s*)false")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_RIA_RULE_R5() {
	file_content=$1
	declare -A rule=(	[name]="RIA_RULE_R5"
						[file]=$f 
						[problem]="Esta expresión es problemática para IExplorer 'renderer:app.format.dateRenderer,'."
						[solution]="Reemplaza esta expresión por su equivalente en el JSON o Dto original." )

	r=$(echo $file_content | grep -E "renderer(\s*):(\s*)app.format.dateRenderer,")
	if [[ "x" != "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_UTF8() {
	file=$1
	declare -A rule=(	[name]="Encodig (UTF-8/ASCII)"
						[file]=$file 
						[problem]="El fichero no está en formato correcto UTF-8 o ASCII."
						[solution]="Convierte el encoding del fichero a u UTF8." )

	encoding=`file -i $file | cut -f 2 -d";" | cut -f 2 -d=`
	if [ $encoding != "utf-8" ] &&  [ $encoding != "us-ascii" ]; then
		paint_error rule
	    exit 1
	fi

}

function check_pitertul_format() {
	f=$1
	expregular=$2
	declare -A rule=(	[name]="Pitertul format"
						[file]=$f
						[problem]="El fichero no está en formato correcto para PITERTUL."
						[solution]="$3"
					)
	r=$(cat $f | tr '\n' ' ' | tr '\t' ' ' | tr -s [:space:] | tr -cd "[:print:]" | 
		grep -a -E -i "$expregular")
	if [[ "x" == "x$r" ]]; then
		paint_error rule
		exit 1
	fi
}

function check_pitertul_name() {
	file=$1
	declare -A rule=(	[name]="Pitertul nombre"
						[file]=$file
						[problem]="El fichero no tiene un nombre correcto para PITERTUL."
						[solution]="Patrón válido: $patron"
					)
	fsinpath=${file##*/}
	if [[ ! $fsinpath =~ $patron ]] ; then 
		paint_error rule
		exit 1
	fi
}

# ***************************
# Control en RIA
# ***************************
function JSP_rules() {
	for f in `eval $modified_files | grep .jsp$`; do
		
		file_content=$(cat $f);

		# R1-RIA. Control de debugger en JSPs
		check_RIA_RULE_R1 "$file_content"
		# R2-RIA.  Control de comentarios en JSPs
		check_RIA_RULE_R2 "$file_content"
		# R3-RIA.  Control de comas furtivas
		check_RIA_RULE_R3 "$file_content"
		# R4-RIA.  Control de reglas border:false (desactivada)
		#check_RIA_RULE_R4 "$file_content"
		# R5-RIA.  Control de reglas dateRenderer()
		check_RIA_RULE_R5 "$file_content"
	done
}

# ***************************
# Control en JS y SQL
# ***************************
function JS_rules() {
	for f in `eval $modified_files | grep .js$`; do
		
		file_content=$(cat $f);

		# R1-RIA. Control de debugger en JSPs
		check_RIA_RULE_R1 "$file_content"
		# R3-RIA.  Control de comas furtivas
		check_RIA_RULE_R3 "$file_content"
	done
}

function SQL_rules() {
	for f in `eval $modified_files | grep  -E \/D.*\.sql$ | grep -v ^reports/ | grep -v migracion | grep -v scripts | grep -v templates | grep -v rutinas`; do
		check_pitertul_name $f
		
		check_UTF8 $f

		exp="\s*WHENEVER\s*SQLERROR\s*EXIT\s*SQL\.SQLCODE(;|)\s*"
		check_pitertul_format $f $exp "Debe incluir 'WHENEVER SQLERROR EXIT SQL.SQLCODE;'"
		exp="SET\s*SERVEROUTPUT\s*ON(;|)"
		check_pitertul_format $f $exp "Debe incluir 'SET SERVEROUTPUT ON;'"
		exp="(DECLARE|CREATE)"
		check_pitertul_format $f $exp "Debe incluir un bloque DECLARE o CREATE"
		exp="BEGIN"
		check_pitertul_format $f $exp "Debe incluir un bloque BEGIN"
		exp="EXCEPTION"
		check_pitertul_format $f $exp "Debe incluir un bloque EXCEPTION"
		exp="ROLLBACK;"
		check_pitertul_format $f $exp "Debe incluir una línea ROLLBACK; dentro del bloque EXCEPTION"
		exp="RAISE;"
		check_pitertul_format $f $exp "Debe incluir  una línea RAISE; dentro del bloque EXCEPTION"
		exp="END(.*);\s*/"
		check_pitertul_format $f $exp "Debe incluir un bloque finalizado con END; o END <nombre_sp>;"
		exp="/\s*EXIT(;|)\s*$"
		check_pitertul_format $f $exp "Debe finalizar con '/ y EXIT'"
	done
}

function PROPERTIES_rules() {
	for f in `eval $modified_files | grep  -E '.properties$'`; do
		check_UTF8 $f
	done
}

function check_conflictos() {
	file=$1
	declare -A rule=(	[name]="Conflictos git no resueltos"
						[file]=$file 
						[problem]="El fichero contiene trazas de conflictos git no resueltos."
						[solution]="Revise que no contenga cadenas '>>>>>>', '<<<<<<<' o '======='." )

	hay_conflictos=`cat $file | grep -E '^[+]?(>>>>>>|<<<<<<<|=======)' | wc -l`
	if [ $hay_conflictos -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function ficheros_rules() {
	for f in `eval $modified_files`; do
		check_conflictos $f
	done
}

function check_esquema_hardcodeado() {
	file=$1
	declare -A rule=(	[name]="Esquema hardcodeado en fichero sql"
						[file]=$file 
						[problem]="Se ha detectado un nombre de esquema hardcodeado en un fichero sql."
						[solution]="Revise que no (contenga BANK01|HAYA0[0-9]|REM01|CM01|ALI01|HAYAMASTER|REMMASTER|ALIMASTER|BANKMASTER|CMMASTER)" )

	existe=`sed "s/--.*$//" $f | grep -iE '(BANK01|HAYA0[0-9]|REM01|CM01|ALI01|ESCO01|SAR01|HAYAMASTER|REMMASTER|ALIMASTER|BANKMASTER|CMMASTER|ESCOMASTER|SARMASTER)' | grep -v WHEN | grep -v THEN | grep -v '=' | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_hardcode_rules() {
	for f in `eval $modified_files | grep -E \/D.*\.sql$ | grep 'producto/' `; do
		check_esquema_hardcodeado $f
	done
}

function check_ddl() {
	file=$1
	declare -A rule=(	[name]="Fichero DDL en una ubicación incorrecta"
						[file]=$file 
						[problem]="Se ha detectado un fichero DDL.sql fuera de la carpeta producto."
						[solution]="Mueva este fichero a la carpeta producto. Sólo se permiten scripts de creación de tablas TMP o AUX fuera de la carpeta de producto" )
	creates_totales=`cat $file | grep -iE "create table " | wc -l`
	creates_ok=`cat $file | grep -iE "create table .*(aux|tmp)" | wc -l`
	echo $creates_totales $creates_ok
	if [ $creates_totales -gt $creates_ok ]; then
		paint_error rule
	    exit 1
	fi
}

function check_ddl_content() {
	file=$1
	declare -A rule=(	[name]="Fichero DDL con contenido incorrecto"
						[file]=$file 
						[problem]="Se han detectado campos o tablas del DDL demasiado largas."
						[solution]="Modifique la longitud menor o igual a 30." )

	IN1=$(cat $file | awk -F- 'NF<=2' $file | tr ',' ' ' | tr '(' ' ' | tr ')' ' '| tr -s ' ' | tr '\n' ' ' | sed 's/a/aA/g; s/__/aB/g; s/#/aC/g' | gcc -P -E $file -  | sed 's/aC/#/g; s/aB/__/g; s/aA/a/g')
	IFS=' ' read -ra ADDR1 <<< "$IN1"
	cons=`echo "${ADDR1[0]}"`
	
	for i in "${ADDR1[@]}"; do
		cons=`echo "$i" | sed 's/[!@#\$%^&*()/;=,:|]//g' | grep -vwE '\w{1,30}' | wc -c`

		if [[ ${cons} -gt 28 ]]; then
			paint_error rule
		    exit 1
		fi
	done
}

function SQL_ddl_rules() {
	for f in `eval $modified_files | grep -E \/DD.*\.sql$ | grep -v producto | grep -v ^procs_y_vistas/ | grep -v ^reports/ | grep -v migracion | grep -v scripts | grep -v templates | grep -v rutinas | grep -v produccion | grep -v incidencias | grep -v rem_fase1 | grep -v informacional | grep -v convivencia | grep -v tmp | grep -v 9\.2 | grep -v 9\.3 | grep -v 9\.4 |  grep -v no_protocolo | grep -v sincro_f2 `; do
		check_ddl $f
		#check_ddl_content $f
	done
}

function check_dml() {
	file=$1
	declare -A rule=(	[name]="Fichero DML con contenido incorrecto"
						[file]=$file 
						[problem]="Se han detectado sentencias DDL dentro de un fichero DML."
						[solution]="Revise que no contenga sentencias (CREATE TABLE|ALTER TABLE|DROP TABLE)" )

	existe=`cat $file | grep -iE "(create table|alter table|drop table)" | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_dml_rules() {
	for f in `eval $modified_files | grep -E \/DM.*\.sql$ | grep -v ^reports/ | grep -v migracion | grep -v scripts | grep -v templates | grep -v rutinas | grep -v produccion | grep -v incidencias | grep -v rem_fase1 | grep -v informacional | grep -v convivencia | grep -v tmp | grep -v 9\.2 | grep -v 9\.3 | grep -v 9\.4 |  grep -v no_protocolo | grep -v sincro_f2 `; do
		check_dml $f
	done
}

function check_select() {
	file=$1
	declare -A rule=(	[name]="Script con contenido incorrecto (SELECT *)"
						[file]=$file 
						[problem]="Se han detectado sentencias SELECT * dentro de un script"
						[solution]="Revise que no contenga sentencias (SELECT *). Sustitúyalas por SELECT <lista_de_campos>" )

	existe=`cat $file | grep -Eia 'SELECT \*' | wc -l`
	if [ $existe -gt 0 ]; then
		paint_error rule
	    exit 1
	fi

}

function SQL_rules2() {
	for f in `eval $modified_files | grep -Ei '*\.sql$'`; do
		check_select $f
	done
}

function Script_schema() {
	file=$1
	
	patron2="^D[D|M]L_[0-9]{3,5}_(DWH|DS)_.*\.sql"

	declare -A rule=(	[name]="Nombre Script/Localización incorrecto dentro de informacional"
						[file]=$file
						[problem]="El fichero se encuentra en una localización incorrecta"
						[solution]="Patrón válido: $patron2"
					)
	fsinpath=${file##*/}
	
	if [[ ! $fsinpath =~ $patron2 ]] ; then 
		paint_error rule
		exit 1
	fi
}

function Script_schema_bi() {
	file=$1
	
	patron2="^D[D|M]L_[0-9]{3,5}_(DWH|DS)_.*\.sql"
	patronNoBi="^D[D|M]L_[0-9]{3,5}_(ENTITY0[0-9]|BANK01|HAYA0[0-9]|REM01|CM01|HAYAMASTER|REMMASTER|MASTER|BANKMASTER|CMMASTER|MINIREC)_.*\.sql"
	declare -A rule=(	[name]="Nombre Script/Localización incorrecto fuera de informacional"
						[file]=$file
						[problem]="El fichero se encuentra en una localización incorrecta"
						[solution]="Patrón válido: $patronNoBi"
					)
	fsinpath=${file##*/}
	
	if [[  $fsinpath =~ $patron2 ]] ; then 
		paint_error rule
		exit 1
	fi
}



function Schema_rules() {
	for f in `eval $modified_files | grep informacional | grep sql`; 
	do 
		Script_schema $f
	done

	for f in `eval $modified_files | grep -v informacional | grep sql`; 
	do 
		Script_schema_bi $f
	done
}

########################################################
##### MAIN
########################################################

SQL_ddl_rules
SQL_dml_rules
SQL_hardcode_rules
ficheros_rules
JSP_rules
JS_rules
SQL_rules
SQL_rules2
Schema_rules


exit 0
